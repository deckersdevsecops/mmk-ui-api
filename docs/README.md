# Merry Maker 2.0

Merry Maker is a fully scalable tool to detect the presence of digital skimmers.

Fundamentally, Merry Maker operationalizes three key processes:

- Preserving a baseline of existing pages by saving the code being served by a website along with the
  network traffic generated by test transactions
- Scanning the saved code for any malicious indicators
- Scanning the saved network traffic for any potential compromise

## Table of Contents
* [FAQ](#frequently-asked-questions)
* [Quickstart](#quickstart)
* [Design](#design)
  * [Sources](#sources)
  * [Sites](#sites)
  * [Scans](#scans)
  * [Alerts](#alerts)
* [Getting Started](#getting-started)
  * [Example Sources](#example-sources)
    * [Basic Source](#basic-source)
    * [Advanced Source](#advanced-source)
  * [Source Functions](#source-functions)
    * [log](#log)
    * [htmlsnapshot](#htmlSnapshot)
    * [screenshot](#screenshot)
    * [Other Useful Functions](#other-useful-functions)
* [Rules](#rules)
  * [Example Skimmer Rule](#example-skimmer-rule)
  * [Example Payload Rule](#example-payload-rule)
  * [Example Javascript Rule](#example-javascript-rule)
* [Configuration](#configuration)
  * [Kafka](#kafka)
  * [GoAlert](#goalert)
* [Advanced](#advanced)
  * [IOC](#ioc)
  * [Seen Strings](#seen-strings)
  * [Allow List](#allow-list)
  * [Secrets](#secrets)


## Frequently Asked Questions
### "What's with the name?"
As the saying goes, there are two hard problems in Computer Science: Naming things, cache invalidation, and off by one errors. Alliteration is always nice as well. Internally it's mostly referred to as MMK.

## Quickstart
The fastest way to try out Merry Maker is to utilize Docker.

```sh
# Start all the services
docker compose -f docker-compose.all.yml up
```

## Design
Merry Maker has a number of core concepts, but the most important are the Source, Site, Scan, and Alert.

### Sources
Sources are the code that is run by the system. It is standard Javascript and the UI provides an interface to add new ones and created updated versions of them. These are intentionally immutable, to protect against accidental deletion and modification. If a Source is in use it can not be removed from the system.

In general, it is a good practice to edit the code in a separate application and then copy the changes into the Source editor for testing. If you need to update an existing source, you do so by copying an existing one, which can be done via the copy button in the Actions column on the Sources page. All sources must have unique names.

The UI for editing Sources also has the option to test them. The output of the test, including screenshots and logging, will be output below the editor.

Before creating the first site, one must create a source. See [here for an example Source](#example-sources) to help you get started.

### Sites
Sites are the parent object for a lot of the data stored in the system. Sites are simple structures. They have Scans and Alerts, as well as four attributes that can be modified directly:
  * Name
  * Schedule
    * Run every 5, 15, 30, 45, or 60 minutes
    * 15 is recommended, as some longer scans may exceed 5 minutes
  * [Source](#sources)
  * Active
    * Whether or not they are live

They also have Alerts and Scans and they have one active Source. Each Site has a Source specified and that Source cannot be deleted as long as it is attached to a Site.

A Site and a Domain name are not analogous. A single domain, say example.com, can have multiple Sites. Think of it more as parts of your site that you want to scan independently of each other. For example, you could have a Site named **Example.com Checkout** to monitor your Checkout process, another one named **Example.com Login** to monitor your login page, and a third named **Example.com User Signup** to monitor your user registration.

### Scans
Scans are the output of the Sources being run. A Scan can have thousands of data points, all of which can have rules run against them. Data collected includes:
 * Cookies
 * Function Calls
 * Log Messages
 * Page Errors
 * Screenshots
 * Scripts Downloaded
 * and more...

The Scan view in the UI allows for searching and filtering these results and provides a Summary view that displays information including the Domains communicated with, the number of Requests, the number of Alerts that were fired, and more.

### Alerts
As Merry Maker is moving through the site, as determined by the Source it is currently following, it is also running the data it is collecting through the rules in the system. If a match occurs, an Alert is fired.

Common Alert types:
  * Known Domain
    * A request has matched a known IOC, typically a known digital skimming domain.
  * Unknown Domain
    * A request has been made to a new domain that the system has not seen before.
  * YARA Skimmer something
    * A YARA rule has matched against one of the Javascript files loaded
  * YARA Payload
    * A YARA rule as matched against some network traffic

By default these Alerts will be added to Merry Maker's database and can be reviewed inside the system. There is also built in support for [GoAlert](#goalert), which is a Target open source project that provides "on-call scheduling, automated escalations, and notifications", and [Kafka](#kafka).

## Getting Started
Merry Maker utilizes [Puppeteer](https://github.com/puppeteer/puppeteer) to control Headless Chrome. Most of the functionality offered by Puppeteer should be usable in Merry Maker, but the main focus is on using the [Page class](https://pptr.dev/#?product=Puppeteer&version=v13.1.1&show=api-class-page).


### Example Sources
As mentioned, the core component of Merry Maker are the Sources it runs. These are written in Javascript and are fairly flexible in what can be done.

#### Basic Source
This example will have the system go to a hypothetical login page, enter the username and password, and then hit the login button. The `log` and `screenshot` functions are [custom builtin Merry Maker functions](#source-functions), described below.


```js
// Go to example.com/login and wait for the page to load
await page.goto('https://www.example.com/login', { waitUntil: 'domcontentloaded' })


log('Entering Password')
await page.focus('#username') // This assume the username field has an ID of "username".

// await page.focus('.username') // CSS class selctors are also supported.
// await page.focus('[name="username"]') // This would select a form field with the name of "username"

// This will tell Puppeteer to simulate typing this into the field, with a 250ms delay between each character
await page.keyboard.type('AzureDiamond', { delay: 250 })

// The two calls above are functionally similar, but not identical, to this shorter call
// await page.type('#username', 'AzureDiamond', { delay: 250 })

log('Entering Password')
await page.focus('#password')
await page.keyboard.type('hunter2', { delay: 250 })

// Take a screenshot to verify that the form fields are filled
await screenshot(page)

// Click the login button
await page.click('#login')

// Wait 5 seconds, to make sure all network traffic is captured
await page.waitForTimeout(5 * 1000)
```

#### Advanced Source
```js
// Set the User Agent to whatever you want
page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36')
// Set a custom viewport size
await page.setViewport({ width: 1440, height: 800 })
// Set a custom cookie.
await page.setCookie(...[{ name: 'special-cookie', value: 'special', domain: '.example.com' }])

// On each request, check to see if the URL includes 'foo-bar' or 'taco-bravo'.
// If it does, cancel the request. This can be handy for when you don't want to
// submit your final order, but you still want to click on the Submit Order button
await page.setRequestInterception(true)
page.on('request', (request) => {
  const url = request.url();
  const filters = [
    'foo-bar',
    'taco-bravo',
  ];
  const shouldAbort = filters.some((urlPart) => url.includes(urlPart));
  if (shouldAbort) {
    request.abort();
  } else {
    request.continue();
  }
});

await page.goto('https://www.example.com/login', { waitUntil: 'domcontentloaded' })

// after the page is loaded, take a snapshot of the DOM to look for malicious code
await htmlSnapshot(page)


```

### Source Functions
It is also possible to write custom functions for these Sources and two are included by default.

#### log
```js
log('Use this like a console.log, but it sends data back to the Merry Maker UI')
log('Useful for testing new Sources')
```

#### htmlSnapshot
```js
// htmlSnapshot captures the current state of the page's DOM. It is then run through
// the rules in skimmer.yara.
await htmlSnapshot(page)
```

#### screenshot
```js
// screenshot takes a screenshot of the current state of the page
// this screenshot is displayed when testing a Source
// and it is also saved as part of the Scan for later review
await screenshot(page)
```

#### Other Useful Functions
These functions make it so Puppeteer can click on Links and Buttons solely based on the text contained in them. The [original source is from this Gist](https://gist.github.com/tokland/d3bae3b6d3c1576d8700405829bbdb52), although the function names have been modified slightly. `clickByText` is for clicking on Buttons, `clickLinkByText` is for clicking on Links.

```js
// required for the clickByText and clickLinkByText functions
const escapeXpathString = str => {
  const splitedQuotes = str.replace(/'/g, `', "'", '`);
  return `concat('${splitedQuotes}', '')`;
};

// usage: await clickByText(page, 'text in the link')
const clickByText = async (page, text) => {
  const escapedText = escapeXpathString(text);
  const linkHandlers = await page.$x(`//button[contains(text(), ${escapedText})]`);

  if (linkHandlers.length > 0) {
    await linkHandlers[0].click();
  } else {
    throw new Error(`Link not found: ${text}`);
  }
};

// usage: await clickLinkByText(page, 'text in the link')
const clickLinkByText = async (page, text) => {
  const escapedText = escapeXpathString(text);
  const linkHandlers = await page.$x(`//a[contains(text(), ${escapedText})]`);

  if (linkHandlers.length > 0) {
    await linkHandlers[0].click();
  } else {
    throw new Error(`Link not found: ${text}`);
  }
};
```

### Secrets
Documentation in progress...

## Rules

### Example Skimmer Rule
Merry Maker ships with a number skimmer rules, intended to run against Javascript files. The existing rules [can be viewed here](https://github.com/target/mmk-ui-api/blob/main/scanner/src/rules/skimmer.yara).

The rules are [written in YARA](https://virustotal.github.io/yara/). YARA is incredibly flexible, and well suited for pattern matching. In general, if you wanted to look for Javascript containing the word "taco" and "bravo", the rule would look like this:

```
rule taco_bravo
{
    meta:
        description = "Look for Taco and Bravo, ignoring capitalization"

    strings:
        $a = "taco" nocase
        $b = "bravo" nocase

    condition:
        $a and $b
}
```

Obviously this is a simple rule. A great source of rules for Digital Skimming YARA rules is [Jérôme Segura's repo](https://github.com/malwareinfosec/webskimmers/tree/main/YARA_rules). Currently, Merry Maker has just one YARA file for skimmer rules. New rules can simply be appended to the end of it. Other publicly available rules that may be useful:
- [SUSP_obfuscated_JS_obfuscatorio](https://github.com/imp0rtp3/yara-rules/blob/main/2021-08-25%20JS%20obfuscator/yara.yar)
- [generic_javascript_obfuscation](https://github.com/codewatchorg/Burp-YARA-Rules/blob/master/javascript_exploit_and_obfuscation.yar#L1)

### Example Payload Rule
Merry Maker also supports writing YARA rules to be run against network traffic. The [two that are included](https://github.com/target/mmk-ui-api/blob/main/scanner/src/rules/ioc.payloads.yara) will need to be customized to be useful. These rules look for a fake credit card and other information to be present in the browser's traffic. The first one looks for it in plaintext, the second one looks for it in base64.

```
rule ioc_payload_checkout_clear_cc {
  meta:
    description = "Checkout Clear CC"
    author = "Eric Brandel"
    reference = ""
    date = "2019-10-14"
  strings:
    $cc_num = "4111123412341234"
    $email = "foo.bar@example.com" nocase
    $firstname = "Kevin" nocase
    $lastname = "Flynn" nocase
  condition:
    any of them
}

rule ioc_payload_checkout_b64_cc {
  meta:
    description = "Checkout base64 CC"
    author = "Eric Brandel"
    reference = ""
    date = "2019-10-14"
  strings:
    $cc_num = "4111123412341234" base64
    $email = "foo.bar@example.com" base64
    $firstname = "Kevin" base64
    $lastname = "Flynn" base64
  condition:
    any of them
}
```

Now, if the Source actually has this credit card being submitted to an endpoint you control, you will just want to add that domain to the [Allow List](#allow-list) as an `ioc-payload-domain`, otherwise this alert would fire every time the Source was run.

### Example Javascript Rule
Documentation in progress...

## Configuration

### Kafka
Documentation in progress...

### GoAlert
[GoAlert Github Repo](https://github.com/target/goalert)
Documentation in progress...


## Advanced
Documentation in progress...

### IOC
Maltrail's [Known Digital Skimming Domains](https://github.com/stamparm/maltrail/blob/master/trails/static/malicious/magentocore.txt)
Documentation in progress...

### Seem Strings
Documentation in progress...

### Allow List
Documentation in progress...

### Secrets
Documentation in progress...
